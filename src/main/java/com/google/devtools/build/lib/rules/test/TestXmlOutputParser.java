// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.devtools.build.lib.rules.test;

import com.google.common.collect.ImmutableSet;
import com.google.devtools.build.lib.view.test.TestStatus.FailedTestCaseDetails;
import com.google.devtools.build.lib.view.test.TestStatus.TestCaseDetail;
import com.google.protobuf.UninitializedMessageException;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;

/**
 * Parses a test.xml generated by jUnit or any testing framework
 * into a protocol buffer. The schema of the test.xml is a bit hazy, so there is
 * some guesswork involved.
 */
class TestXmlOutputParser {
  private static class HierarchicalTestResult {
    private List<HierarchicalTestResult> children = new ArrayList<>();
    private String name;
    private String className;        // Not used for suites or decorators.
    private long runDurationMillis;
    private int failures;
    private int errors;
  };

  // jUnit can use either "testsuites" or "testsuite".
  private static final Collection<String> TOPLEVEL_ELEMENT_NAMES =
      ImmutableSet.of("testsuites", "testsuite");

  public FailedTestCaseDetails parseXmlIntoTestResult(InputStream xmlStream)
      throws TestXmlOutputParserException {
    HierarchicalTestResult result = parseXmlToTree(xmlStream);
    FailedTestCaseDetails.Builder builder = FailedTestCaseDetails.newBuilder();
    // will be overwritten if something goes wrong.
    builder.setStatus(FailedTestCaseDetails.Status.FULL);
    collectFailedTestCases(result, builder);
    return builder.build();
  }

  private static void collectFailedTestCases(
      HierarchicalTestResult hierarchicalResult, FailedTestCaseDetails.Builder testCaseDetails) {
    if (!hierarchicalResult.children.isEmpty()) {
      // This is a non-leaf result. Traverse its children, but do not add its
      // name to the output list. It should not contain any 'failure' or
      // 'error' tags, but we want to be lax here, because the syntax of the
      // test.xml file is also lax.
      for (HierarchicalTestResult child : hierarchicalResult.children) {
        collectFailedTestCases(child, testCaseDetails);
      }
    } else {
      // This is a leaf result. If there was a failure or an error, return it.
      boolean passed = hierarchicalResult.failures == 0
          && hierarchicalResult.errors == 0;
      if (passed) {
        return;
      }

      String name = hierarchicalResult.name;
      String className = hierarchicalResult.className;
      if (name == null || className == null) {
        // A test case detail is not really interesting if we cannot tell which
        // one it is.
        testCaseDetails.setStatus(FailedTestCaseDetails.Status.PARTIAL);
        return;
      }

      // TODO(bazel-team): The dot separator is only correct for Java.
      String testCaseName = className + "." + name;

      testCaseDetails.addDetail(TestCaseDetail.newBuilder()
          .setName(testCaseName)
          .setStatus(hierarchicalResult.errors > 0
              ? TestCaseDetail.Status.ERROR : TestCaseDetail.Status.FAILED)
          .setRunDurationMillis(hierarchicalResult.runDurationMillis)
          .build());
    }
  }

  /**
   * Parses the a test result XML file into the corresponding protocol buffer.
   * @param xmlStream the XML data stream
   * @return the protocol buffer with the parsed data, or null if there was
   * an error while parsing the file.
   *
   * @throws TestXmlOutputParserException when the XML file cannot be parsed
   */
  private HierarchicalTestResult parseXmlToTree(InputStream xmlStream)
      throws TestXmlOutputParserException {
    XMLStreamReader parser = null;

    try {
      parser = XMLInputFactory.newInstance().createXMLStreamReader(xmlStream);

      while (true) {
        int event = parser.next();
        if (event == XMLStreamConstants.END_DOCUMENT) {
          return null;
        }

        // First find the topmost node.
        if (event == XMLStreamConstants.START_ELEMENT) {
          String elementName = parser.getLocalName();
          if (TOPLEVEL_ELEMENT_NAMES.contains(elementName)) {
            HierarchicalTestResult result = parseTestSuite(parser, elementName);
            return result;
          }
        }
      }
    } catch (XMLStreamException e) {
      throw new TestXmlOutputParserException(e);
    }  catch (NumberFormatException e) {
      // The parser is definitely != null here.
      throw new TestXmlOutputParserException(
          "Number could not be parsed at "
          + parser.getLocation().getLineNumber() + ":"
          + parser.getLocation().getColumnNumber(),
          e);
    } catch (UninitializedMessageException e) {
      // This happens when the XML does not contain a field that is required
      // in the protocol buffer
      throw new TestXmlOutputParserException(e);
    } catch (RuntimeException e) {

      // Seems like that an XNIException can leak through, even though it is not
      // specified anywhere.
      //
      // It's a bad idea to refer to XNIException directly because the Xerces
      // documentation says that it may not be available here soon (and it
      // results in a compile-time warning anyway), so we do it the roundabout
      // way: check if the class name has something to do with Xerces, and if
      // so, wrap it in our own exception type, otherwise, let the stack
      // unwinding continue.
      String name = e.getClass().getCanonicalName();
      if (name != null && name.contains("org.apache.xerces")) {
        throw new TestXmlOutputParserException(e);
      } else {
        throw e;
      }
    } finally {
      if (parser != null) {
        try {
          parser.close();
        } catch (XMLStreamException e) {

          // Ignore errors during closure so that we do not interfere with an
          // already propagating exception.
        }
      }
    }
  }

  /**
   * Creates an exception suitable to be thrown when and a bad end tag appears.
   * The exception could also be thrown from here but that would result in an
   * extra stack frame, whereas this way, the topmost frame shows the location
   * where the error occurred.
   */
  private TestXmlOutputParserException createBadElementException(
      String expected, XMLStreamReader parser) {
    return new TestXmlOutputParserException("Expected end of XML element '"
        + expected + "' , but got '" + parser.getLocalName() + "' at "
        + parser.getLocation().getLineNumber() + ":"
        + parser.getLocation().getColumnNumber());
  }

  /**
   * Parses a 'testsuite' element.
   *
   * @throws TestXmlOutputParserException if the XML document is malformed
   * @throws XMLStreamException if there was an error processing the XML
   * @throws NumberFormatException if one of the numeric fields does not contain
   *         a valid number
   */
  private HierarchicalTestResult parseTestSuite(XMLStreamReader parser, String elementName)
      throws XMLStreamException, TestXmlOutputParserException {
    HierarchicalTestResult result = new HierarchicalTestResult();

    for (int i = 0; i < parser.getAttributeCount(); i++) {
      String name = parser.getAttributeLocalName(i).intern();
      String value = parser.getAttributeValue(i);

      if (name.equals("name")) {
        result.name = value;
      } else if (name.equals("time")) {
        result.runDurationMillis = parseTime(value);
      }
    }

    parseContainedElements(parser, elementName, result);
    return result;
  }

  /**
   * Parses a time in test.xml format.
   *
   * @throws NumberFormatException if the time is malformed (i.e. is neither an
   * integer nor a decimal fraction with '.' as the fraction separator)
   */
  private long parseTime(String string) {

    // This is ugly. For Historical Reasons, we have to check whether the number
    // contains a decimal point or not. If it does, the number is expressed in
    // milliseconds, otherwise, in seconds.
    if (string.contains(".")) {
      return Math.round(Float.parseFloat(string) * 1000);
    } else {
      return Long.parseLong(string);
    }
  }

  /**
   * Parses a 'decorator' element.
   *
   * @throws TestXmlOutputParserException if the XML document is malformed
   * @throws XMLStreamException if there was an error processing the XML
   * @throws NumberFormatException if one of the numeric fields does not contain
   *         a valid number
   */
  private HierarchicalTestResult parseTestDecorator(XMLStreamReader parser)
      throws XMLStreamException, TestXmlOutputParserException {
    HierarchicalTestResult result = new HierarchicalTestResult();

    for (int i = 0; i < parser.getAttributeCount(); i++) {
      String name = parser.getAttributeLocalName(i);
      String value = parser.getAttributeValue(i);

      result.name = name.intern();
      if (name.equals("classname")) {
        result.className = value;
      } else if (name.equals("time")) {
        result.runDurationMillis = parseTime(value);
      }
    }

    parseContainedElements(parser, "testdecorator", result);
    return result;
  }

  /**
   * Parses child elements of the specified tag. Strictly speaking, not every
   * element can be a child of every other, but the HierarchicalTestResult can
   * handle that, and (in this case) it does not hurt to be a bit more flexible
   * than necessary.
   *
   * @throws TestXmlOutputParserException if the XML document is malformed
   * @throws XMLStreamException if there was an error processing the XML
   * @throws NumberFormatException if one of the numeric fields does not contain
   *         a valid number
   */
  private void parseContainedElements(
      XMLStreamReader parser, String elementName, HierarchicalTestResult result)
      throws XMLStreamException, TestXmlOutputParserException {
    while (true) {
      int event = parser.next();
      switch (event) {
        case XMLStreamConstants.START_ELEMENT:
          String childElementName = parser.getLocalName().intern();

          // We are not parsing four elements here: system-out, system-err,
          // failure and error. They potentially contain useful information, but
          // they can be too big to fit in the memory. We add failure and error
          // elements to the output without a message, so that there is a
          // difference between passed and failed test cases.
          if (childElementName.equals("testsuite")) {
            result.children.add(parseTestSuite(parser, childElementName));
          } else if (childElementName.equals("testcase")) {
            result.children.add(parseTestCase(parser));
          } else if (childElementName.equals("failure")) {
            result.failures++;
            skipCompleteElement(parser);
          } else if (childElementName.equals("error")) {
            result.errors++;
            skipCompleteElement(parser);
          } else if (childElementName.equals("testdecorator")) {
            result.children.add(parseTestDecorator(parser));
          } else {

            // Unknown element encountered. Since the schema of the input file
            // is a bit hazy, just skip it and go merrily on our way. Ignorance
            // is bliss.
            skipCompleteElement(parser);
          }
          break;

        case XMLStreamConstants.END_ELEMENT:

          // This is the end tag of the element we are supposed to parse.
          // Hooray, tell our superiors that our mission is complete.
          if (!parser.getLocalName().equals(elementName)) {
            throw createBadElementException(elementName, parser);
          }
          return;
      }
    }
  }


  /**
   * Parses a 'testcase' element.
   *
   * @throws TestXmlOutputParserException if the XML document is malformed
   * @throws XMLStreamException if there was an error processing the XML
   * @throws NumberFormatException if the time field does not contain a valid
   *         number
   */
  private HierarchicalTestResult parseTestCase(XMLStreamReader parser)
      throws XMLStreamException, TestXmlOutputParserException {
    HierarchicalTestResult result = new HierarchicalTestResult();

    for (int i = 0; i < parser.getAttributeCount(); i++) {
      String name = parser.getAttributeLocalName(i).intern();
      String value = parser.getAttributeValue(i);

      if (name.equals("name")) {
        result.name = value;
      } else if (name.equals("classname")) {
        result.className = value;
      } else if (name.equals("time")) {
        result.runDurationMillis = parseTime(value);
      }
    }

    parseContainedElements(parser, "testcase", result);
    return result;
  }

  /**
   * Skips over a complete XML element on the input.
   * Precondition: the cursor is at a START_ELEMENT.
   * Postcondition: the cursor is at an END_ELEMENT.
   *
   * @throws XMLStreamException if the XML is malformed
   */
  private void skipCompleteElement(XMLStreamReader parser) throws XMLStreamException {
    int depth = 1;
    while (true) {
      int event = parser.next();

      switch (event) {
        case XMLStreamConstants.START_ELEMENT:
          depth++;
          break;

        case XMLStreamConstants.END_ELEMENT:
          if (--depth == 0) {
            return;
          }
          break;
      }
    }
  }
}
